<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Pubky Ring Auth</title>
    <link rel="stylesheet" href="styles/shadcn.css" />
    <style>
      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        gap: 1.5rem;
      }
      #qr {
        width: 280px;
        height: 280px;
        background: var(--surface);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 1rem;
        border-radius: 16px;
        border: 1px solid var(--border);
      }
      pre {
        background: var(--surface);
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid var(--border);
        max-width: 90vw;
        overflow-wrap: anywhere;
      }
      #status {
        font-size: 1.2rem;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Scan with Pubky Ring</h1>
      <div id="qr"></div>
      <pre id="link"></pre>
      <p id="status">Waiting for approvalâ€¦</p>
    </main>
    <script>
      // QR Code generator (Kazuhiko Arase, MIT, trimmed)
      (function(global) {
        function QR8bitByte(data) {
          this.mode = QRMode.MODE_8BIT_BYTE;
          this.data = data;
        }
        QR8bitByte.prototype = {
          getLength: function() {
            return this.data.length;
          },
          write: function(buffer) {
            for (var i = 0; i < this.data.length; i++) {
              buffer.put(this.data.charCodeAt(i), 8);
            }
          }
        };

        var QRMode = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4 };
        var QRErrorCorrectionLevel = { L: 1, M: 0, Q: 3, H: 2 };
        var QRMaskPattern = {
          PATTERN000: 0,
          PATTERN001: 1,
          PATTERN010: 2,
          PATTERN011: 3,
          PATTERN100: 4,
          PATTERN101: 5,
          PATTERN110: 6,
          PATTERN111: 7
        };

        var QRUtil = {
          PATTERN_POSITION_TABLE: [
            [],
            [6, 18],
            [6, 22],
            [6, 26],
            [6, 30],
            [6, 34],
            [6, 22, 38],
            [6, 24, 42],
            [6, 26, 46],
            [6, 28, 50],
            [6, 30, 54],
            [6, 32, 58],
            [6, 34, 62],
            [6, 26, 46, 66],
            [6, 26, 48, 70],
            [6, 26, 50, 74]
          ],
          G15: 1335,
          G18: 7973,
          G15_MASK: 21522,
          getBCHTypeInfo: function(data) {
            var d = data << 10;
            while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
              d ^= QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15));
            }
            return (data << 10) | d;
          },
          getBCHTypeNumber: function(data) {
            var d = data << 12;
            while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
              d ^= QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18));
            }
            return (data << 12) | d;
          },
          getBCHDigit: function(data) {
            var digit = 0;
            while (data !== 0) {
              digit++;
              data >>>= 1;
            }
            return digit;
          },
          getPatternPosition: function(typeNumber) {
            return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
          },
          getMask: function(maskPattern, i, j) {
            switch (maskPattern) {
              case QRMaskPattern.PATTERN000: return (i + j) % 2 === 0;
              case QRMaskPattern.PATTERN001: return i % 2 === 0;
              case QRMaskPattern.PATTERN010: return j % 3 === 0;
              case QRMaskPattern.PATTERN011: return (i + j) % 3 === 0;
              case QRMaskPattern.PATTERN100: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
              case QRMaskPattern.PATTERN101: return ((i * j) % 2 + (i * j) % 3) === 0;
              case QRMaskPattern.PATTERN110: return (((i * j) % 2 + (i * j) % 3) % 2) === 0;
              case QRMaskPattern.PATTERN111: return (((i * j) % 3 + (i + j) % 2) % 2) === 0;
              default: throw new Error('bad mask');
            }
          },
          getErrorCorrectPolynomial: function(errorCorrectLength) {
            var a = new QRPolynomial([1], 0);
            for (var i = 0; i < errorCorrectLength; i++) {
              a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
            }
            return a;
          },
          getLengthInBits: function(mode, type) {
            if (type < 10) {
              switch (mode) {
                case QRMode.MODE_NUMBER: return 10;
                case QRMode.MODE_ALPHA_NUM: return 9;
                case QRMode.MODE_8BIT_BYTE: return 8;
              }
            } else if (type < 27) {
              switch (mode) {
                case QRMode.MODE_NUMBER: return 12;
                case QRMode.MODE_ALPHA_NUM: return 11;
                case QRMode.MODE_8BIT_BYTE: return 16;
              }
            } else {
              switch (mode) {
                case QRMode.MODE_NUMBER: return 14;
                case QRMode.MODE_ALPHA_NUM: return 13;
                case QRMode.MODE_8BIT_BYTE: return 16;
              }
            }
            return 0;
          },
          getLostPoint: function(qrCode) {
            var moduleCount = qrCode.getModuleCount();
            var lostPoint = 0;
            for (var row = 0; row < moduleCount; row++) {
              for (var col = 0; col < moduleCount; col++) {
                var sameCount = 0;
                var dark = qrCode.isDark(row, col);
                for (var r = -1; r <= 1; r++) {
                  if (row + r < 0 || moduleCount <= row + r) continue;
                  for (var c = -1; c <= 1; c++) {
                    if (col + c < 0 || moduleCount <= col + c) continue;
                    if (r === 0 && c === 0) continue;
                    if (dark === qrCode.isDark(row + r, col + c)) sameCount++;
                  }
                }
                if (sameCount > 5) lostPoint += 3 + sameCount - 5;
              }
            }
            for (row = 0; row < moduleCount - 1; row++) {
              for (col = 0; col < moduleCount - 1; col++) {
                var count = 0;
                if (qrCode.isDark(row, col)) count++;
                if (qrCode.isDark(row + 1, col)) count++;
                if (qrCode.isDark(row, col + 1)) count++;
                if (qrCode.isDark(row + 1, col + 1)) count++;
                if (count === 0 || count === 4) lostPoint += 3;
              }
            }
            for (row = 0; row < moduleCount; row++) {
              for (col = 0; col < moduleCount - 6; col++) {
                if (qrCode.isDark(row, col) && !qrCode.isDark(row, col + 1) &&
                    qrCode.isDark(row, col + 2) && qrCode.isDark(row, col + 3) &&
                    qrCode.isDark(row, col + 4) && !qrCode.isDark(row, col + 5) &&
                    qrCode.isDark(row, col + 6)) {
                  lostPoint += 40;
                }
              }
            }
            for (col = 0; col < moduleCount; col++) {
              for (row = 0; row < moduleCount - 6; row++) {
                if (qrCode.isDark(row, col) && !qrCode.isDark(row + 1, col) &&
                    qrCode.isDark(row + 2, col) && qrCode.isDark(row + 3, col) &&
                    qrCode.isDark(row + 4, col) && !qrCode.isDark(row + 5, col) &&
                    qrCode.isDark(row + 6, col)) {
                  lostPoint += 40;
                }
              }
            }
            var darkCount = 0;
            for (col = 0; col < moduleCount; col++) {
              for (row = 0; row < moduleCount; row++) {
                if (qrCode.isDark(row, col)) darkCount++;
              }
            }
            var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
            lostPoint += ratio * 10;
            return lostPoint;
          }
        };
        var QRMath = {
          glog: function(n) {
            if (n < 1) throw new Error('glog');
            return QRMath.LOG_TABLE[n];
          },
          gexp: function(n) {
            while (n < 0) n += 255;
            while (n >= 256) n -= 255;
            return QRMath.EXP_TABLE[n];
          },
          EXP_TABLE: new Array(256),
          LOG_TABLE: new Array(256)
        };
        for (var i = 0; i < 8; i++) QRMath.EXP_TABLE[i] = 1 << i;
        for (i = 8; i < 256; i++) QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
        for (i = 0; i < 255; i++) QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;

        function QRPolynomial(num, shift) {
          if (num.length === undefined) throw new Error(num.length + '/' + shift);
          var offset = 0;
          while (offset < num.length && num[offset] === 0) offset++;
          this.num = new Array(num.length - offset + shift);
          for (var i = 0; i < num.length - offset; i++) this.num[i] = num[i + offset];
        }
        QRPolynomial.prototype = {
          get: function(index) {
            return this.num[index];
          },
          getLength: function() {
            return this.num.length;
          },
          multiply: function(e) {
            var num = new Array(this.getLength() + e.getLength() - 1);
            for (var i = 0; i < this.getLength(); i++) {
              for (var j = 0; j < e.getLength(); j++) {
                num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
              }
            }
            return new QRPolynomial(num, 0);
          },
          mod: function(e) {
            if (this.getLength() - e.getLength() < 0) return this;
            var ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
            var num = new Array(this.getLength());
            for (var i = 0; i < this.getLength(); i++) num[i] = this.get(i);
            for (i = 0; i < e.getLength(); i++) {
              num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
            }
            return new QRPolynomial(num, 0).mod(e);
          }
        };
        function QRRSBlock(totalCount, dataCount) {
          this.totalCount = totalCount;
          this.dataCount = dataCount;
        }
        QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
          var rsBlock = QRRSBlock.TABLE[(typeNumber - 1) * 4 + errorCorrectLevel];
          var list = [];
          for (var i = 0; i < rsBlock.length / 3; i++) {
            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];
            for (var j = 0; j < count; j++) {
              list.push(new QRRSBlock(totalCount, dataCount));
            }
          }
          return list;
        };
        QRRSBlock.TABLE = [
          1, 26, 19,
          1, 26, 16,
          1, 26, 13,
          1, 26, 9
        ];

        function QRBitBuffer() {
          this.buffer = [];
          this.length = 0;
        }
        QRBitBuffer.prototype = {
          get: function(index) {
            return ((this.buffer[Math.floor(index / 8)] >>> (7 - index % 8)) & 1) === 1;
          },
          put: function(num, length) {
            for (var i = 0; i < length; i++) {
              this.putBit(((num >>> (length - i - 1)) & 1) === 1);
            }
          },
          getLengthInBits: function() {
            return this.length;
          },
          putBit: function(bit) {
            var bufIndex = Math.floor(this.length / 8);
            if (this.buffer.length <= bufIndex) this.buffer.push(0);
            if (bit) this.buffer[bufIndex] |= 0x80 >>> (this.length % 8);
            this.length++;
          }
        };
        function QRCodeModel(typeNumber, errorCorrectLevel) {
          this.typeNumber = typeNumber;
          this.errorCorrectLevel = errorCorrectLevel;
          this.modules = null;
          this.moduleCount = 0;
          this.dataCache = null;
          this.dataList = [];
        }
        QRCodeModel.prototype = {
          addData: function(data) {
            var newData = new QR8bitByte(data);
            this.dataList.push(newData);
            this.dataCache = null;
          },
          isDark: function(row, col) {
            return this.modules[row][col];
          },
          getModuleCount: function() {
            return this.moduleCount;
          },
          make: function() {
            if (this.typeNumber < 1) this.typeNumber = 1;
            this.makeImpl(false, this.getBestMaskPattern());
          },
          makeImpl: function(test, maskPattern) {
            this.moduleCount = this.typeNumber * 4 + 17;
            this.modules = new Array(this.moduleCount);
            for (var row = 0; row < this.moduleCount; row++) {
              this.modules[row] = new Array(this.moduleCount);
              for (var col = 0; col < this.moduleCount; col++) {
                this.modules[row][col] = null;
              }
            }
            this.setupPositionProbePattern(0, 0);
            this.setupPositionProbePattern(this.moduleCount - 7, 0);
            this.setupPositionProbePattern(0, this.moduleCount - 7);
            this.setupPositionAdjustPattern();
            this.setupTimingPattern();
            this.setupTypeInfo(test, maskPattern);
            if (this.typeNumber >= 7) this.setupTypeNumber(test);
            if (this.dataCache == null) {
              this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
            }
            this.mapData(this.dataCache, maskPattern);
          },
          setupPositionProbePattern: function(row, col) {
            for (var r = -1; r <= 7; r++) {
              if (row + r <= -1 || this.moduleCount <= row + r) continue;
              for (var c = -1; c <= 7; c++) {
                if (col + c <= -1 || this.moduleCount <= col + c) continue;
                if (r >= 0 && r <= 6 && (c === 0 || c === 6) ||
                    c >= 0 && c <= 6 && (r === 0 || r === 6) ||
                    r >= 2 && r <= 4 && c >= 2 && c <= 4) {
                  this.modules[row + r][col + c] = true;
                } else {
                  this.modules[row + r][col + c] = false;
                }
              }
            }
          },
          setupTimingPattern: function() {
            for (var r = 8; r < this.moduleCount - 8; r++) {
              if (this.modules[r][6] != null) continue;
              this.modules[r][6] = (r % 2 === 0);
            }
            for (var c = 8; c < this.moduleCount - 8; c++) {
              if (this.modules[6][c] != null) continue;
              this.modules[6][c] = (c % 2 === 0);
            }
          },
          setupPositionAdjustPattern: function() {
            var pos = QRUtil.getPatternPosition(this.typeNumber);
            for (var i = 0; i < pos.length; i++) {
              for (var j = 0; j < pos.length; j++) {
                var row = pos[i];
                var col = pos[j];
                if (this.modules[row][col] != null) continue;
                for (var r = -2; r <= 2; r++) {
                  for (var c = -2; c <= 2; c++) {
                    this.modules[row + r][col + c] = (r === -2 || r === 2 || c === -2 || c === 2 || (r === 0 && c === 0));
                  }
                }
              }
            }
          },
          setupTypeNumber: function(test) {
            var bits = QRUtil.getBCHTypeNumber(this.typeNumber);
            for (var i = 0; i < 18; i++) {
              var mod = (!test && ((bits >> i) & 1) === 1);
              this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
              this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
            }
          },
          setupTypeInfo: function(test, maskPattern) {
            var data = (QRErrorCorrectionLevel.M << 3) | maskPattern;
            var bits = QRUtil.getBCHTypeInfo(data);
            for (var i = 0; i < 15; i++) {
              var mod = (!test && ((bits >> i) & 1) === 1);
              this.modules[i < 6 ? i : i < 8 ? i + 1 : this.moduleCount - 15 + i][8] = mod;
              this.modules[8][i < 8 ? this.moduleCount - i - 1 : 14 - i] = mod;
            }
          },
          mapData: function(data, maskPattern) {
            var inc = -1;
            var row = this.moduleCount - 1;
            var bitIndex = 0;
            var byteIndex = 0;
            for (var col = this.moduleCount - 1; col > 0; col -= 2) {
              if (col === 6) col--;
              while (true) {
                for (var c = 0; c < 2; c++) {
                  if (this.modules[row][col - c] == null) {
                    var dark = false;
                    if (byteIndex < data.length) {
                      dark = (((data[byteIndex] >>> (7 - bitIndex)) & 1) === 1);
                    }
                    var mask = QRUtil.getMask(maskPattern, row, col - c);
                    this.modules[row][col - c] = dark !== mask;
                    bitIndex++;
                    if (bitIndex === 8) {
                      byteIndex++;
                      bitIndex = 0;
                    }
                  }
                }
                row += inc;
                if (row < 0 || this.moduleCount <= row) {
                  row -= inc;
                  inc = -inc;
                  break;
                }
              }
            }
          },
          getBestMaskPattern: function() {
            var minLostPoint = 0;
            var pattern = 0;
            for (var i = 0; i < 8; i++) {
              this.makeImpl(true, i);
              var lostPoint = QRUtil.getLostPoint(this);
              if (i === 0 || minLostPoint > lostPoint) {
                minLostPoint = lostPoint;
                pattern = i;
              }
            }
            return pattern;
          }
        };
        QRCodeModel.PAD0 = 0xec;
        QRCodeModel.PAD1 = 0x11;
        QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
          var buffer = new QRBitBuffer();
          for (var i = 0; i < dataList.length; i++) {
            var data = dataList[i];
            buffer.put(data.mode, 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
            data.write(buffer);
          }
          var totalDataCount = 0;
          for (i = 0; i < rsBlocks.length; i++) totalDataCount += rsBlocks[i].dataCount;
          if (buffer.getLengthInBits() > totalDataCount * 8) throw new Error('code length overflow');
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) buffer.put(0, 4);
          while (buffer.getLengthInBits() % 8 !== 0) buffer.putBit(false);
          while (buffer.getLengthInBits() < totalDataCount * 8) {
            buffer.put(QRCodeModel.PAD0, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) break;
            buffer.put(QRCodeModel.PAD1, 8);
          }
          return QRCodeModel.createBytes(buffer, rsBlocks);
        };
        QRCodeModel.createBytes = function(buffer, rsBlocks) {
          var offset = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          var dcdata = [];
          var ecdata = [];
          for (var r = 0; r < rsBlocks.length; r++) {
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
            dcdata[r] = new Array(dcCount);
            for (var i = 0; i < dcdata[r].length; i++) {
              dcdata[r][i] = 0xff & buffer.buffer[i + offset];
            }
            offset += dcCount;
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (i = 0; i < ecdata[r].length; i++) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = modIndex >= 0 ? modPoly.get(modIndex) : 0;
            }
          }
          var totalCodeCount = 0;
          for (r = 0; r < rsBlocks.length; r++) totalCodeCount += rsBlocks[r].totalCount;
          var data = new Array(totalCodeCount);
          var index = 0;
          for (var i = 0; i < maxDcCount; i++) {
            for (r = 0; r < rsBlocks.length; r++) {
              if (i < dcdata[r].length) data[index++] = dcdata[r][i];
            }
          }
          for (var i = 0; i < maxEcCount; i++) {
            for (r = 0; r < rsBlocks.length; r++) {
              if (i < ecdata[r].length) data[index++] = ecdata[r][i];
            }
          }
          return data;
        };
        function QRCode(typeNumber, errorCorrectLevel) {
          this.model = new QRCodeModel(typeNumber, errorCorrectLevel);
        }
        QRCode.prototype.addData = function(data) {
          this.model.addData(data);
        };
        QRCode.prototype.make = function() {
          this.model.make();
        };
        QRCode.prototype.createCanvas = function(size) {
          var canvas = document.createElement('canvas');
          canvas.width = canvas.height = size;
          var ctx = canvas.getContext('2d');
          var moduleCount = this.model.getModuleCount();
          var scale = size / moduleCount;
          for (var row = 0; row < moduleCount; row++) {
            for (var col = 0; col < moduleCount; col++) {
              ctx.fillStyle = this.model.isDark(row, col) ? '#0f1015' : '#e6e7ef';
              var x = Math.round(col * scale);
              var y = Math.round(row * scale);
              var w = Math.ceil((col + 1) * scale) - x;
              var h = Math.ceil((row + 1) * scale) - y;
              ctx.fillRect(x, y, w, h);
            }
          }
          return canvas;
        };
        global.QRCode = function(text) {
          for (var type = 2; type <= 16; type += 2) {
            try {
              var qr = new QRCode(type, QRErrorCorrectionLevel.M);
              qr.addData(text);
              qr.make();
              return qr.createCanvas(280);
            } catch (err) {
              if (type >= 10) throw err;
            }
          }
          throw new Error('QR generation failed');
        };
      })(window);

      (function() {
        const params = new URLSearchParams(location.hash.slice(1));
        const authUrl = params.get('auth');
        const statusUrl = params.get('status');
        if (!authUrl || !statusUrl) {
          document.getElementById('status').textContent = 'Missing auth data';
          return;
        }
        const decoded = decodeURIComponent(authUrl);
        document.getElementById('link').textContent = decoded;
        const canvas = QRCode(decoded);
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        document.getElementById('qr').appendChild(canvas);
        poll(statusUrl);
      })();

      async function poll(statusUrl) {
        const deadline = Date.now() + 180000;
        const statusEl = document.getElementById('status');
        while (Date.now() < deadline) {
          try {
            const res = await fetch(statusUrl);
            if (!res.ok) throw new Error('bad');
            const data = await res.json();
            if (data.status === 'approved') {
              statusEl.textContent = 'Authenticated!';
              return;
            }
            if (data.status === 'denied' || data.status === 'expired') {
              statusEl.textContent = 'Auth denied or expired.';
              return;
            }
          } catch (err) {
            console.error(err);
          }
          await new Promise((resolve) => setTimeout(resolve, 1000));
        }
        statusEl.textContent = 'Auth timeout.';
      }
    </script>
  </body>
</html>
